Pentru functia proximal_2x2, am creat mai intai vectorul x_int incepand de la unu pana la doi si am adaugat step-ul la fiecare element, folosind un for.Apoi am initializat matricea nula. Am parcurs imaginea pixel cu pixel si am folosit functia round pentru aproximari. Apoi am completat matricea de output cu noile valori.
In cadrul functiei  proximal_2x2_RGB am separat cele trei canale RGB si le-am stocat in variabilele denumite redChannel, greenChannel si blueChannel. Apoi le-am introdus separat in functia proximal_2x2 si le-am retinut intr-o alta serie de variabile red, blue, green(stiu ca puteam sa fac functia asta fara sa mai folosesc si ultimele trei variabile dar mi s-a parut mai lizibil).In final am folosit functia cat pentru a forma imaginea finala.La fiecare functie RGB am facurt acelasi lucru in principiu.
In functia resize am initializat o alta matrice nula. Apoi am calculat exact cum spunea in cerinta factorii de scalare. In continuare am definit matricea de transformare, dar si matricea inversa, observand ca valorile de pe diagonale ale matricei inverse sunt egale cu 1/valorile matricei de transformare.Apoi am parcurs iar imaginea pixel cu pixel, insa de data aceasta de la 0 .Am aplicat in cadrul for-urilor transformarea inversa si am calculat xp si yp.Am incrementat cele doua variabile pentru a le trece in sistemul de coordonate [1,n] si le-am rotunjit.In final am facut transformarea matricei rezultate in uint8.
La functia Rotate am petrecut putin mai mult ca sa inteleg ce ar trebui sa fac mai exact. Am inceput cu calculul functiilor cosinus, sinus si a matricei de transformare, respectiv inversa ei. Apoi am parcurs imaginea cu doua for-uri si am aplicat transformare inversa pentru a calcula x_p si y_p. Am luat in considerare si cazul in care x_p si y_p se afla in exteriorul marginilor imaginii si am completat cu pixeli negri.Apoi am aflat punctele ce inconjoara xp si yp, folosind functiile predefinite floor si ceil pentru a aproxima valorile. Apoi am verificat pe rand cazurilw in care punctele sunt egale(x1 si x2, y1 si y2) si am completat matricea conform fiecarei variante. Am scris o functie separat intr-un script denumit coef.m pentru calculul coeficientilor de interpolare. In cadrul acestei functii am folosit o matrice auxiliara A formata cu ajutorul valorilor x1, x2, y1 si y2 calculate anterior si cu ajutorul formulei am reusit sa calculez ce trebuia.In final am transformat matricea rezultat in uint8 si am castat matricea I  a imaginii la double pentru a lua punctaj maxim pe aceasta cerinta.

La interpolarea bicubica, precalc_d.m am facut trei functii separate:fx,fy si fxy pentru calculul derivatelor,  folosind formulele. Apoi doar am calcular matricile cu derivate fata de x, y si xy.
La functia bicubic_resize am initializat din nou matricea finala ca o matrice nula. Am calculat matricea de transformare si inversa ei, iar apoi derivatele. Cu ajutorul a for-uri am parcurs matricea si pentru fiecare pixel am aplicat transformarea inversa pentru a calcula x_p si y_p.Am folsit din nou functiile floor si ceil pentru a gasi cele patru puncte ce inconjoara punctul x,y. In final, am calculat coeficientii de interpolare apeland functia scris anterior bicubic_coef si am calculat valoarea interpolata a pixelului x,y.